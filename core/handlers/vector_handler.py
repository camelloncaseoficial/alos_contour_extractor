# -*- coding: utf-8 -*-

"""
/***************************************************************************
 AlosContourExtractor
                                 A QGIS plugin
 Creates contour and elevation points from Alos Palsar DEM
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-07-20
        copyright            : (C) 2021 by CamellOnCase
        email                : camelloncase@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Francisco Alves Camello Neto'
__date__ = '2021-07-20'
__copyright__ = '(C) 2021 by CamellOnCase'

import math
import numpy as np
import processing
from qgis.analysis import QgsGeometrySnapper, QgsInternalGeometrySnapper
from qgis.core import (edit, Qgis, QgsCoordinateReferenceSystem, QgsCoordinateTransform,
                       QgsExpression, QgsFeature, QgsFeatureRequest, QgsField, QgsFields, QgsGeometry, QgsMessageLog,
                       QgsProcessingContext, QgsProcessingMultiStepFeedback, QgsProcessingUtils, QgsProject,
                       QgsSpatialIndex, QgsVectorDataProvider, QgsVectorLayer, QgsVectorLayerUtils, QgsWkbTypes,
                       QgsProcessingFeatureSourceDefinition, QgsFeatureSink)
from qgis.PyQt.Qt import QObject, QVariant
from ..algorithms.algorithm_runner import AlgorithmRunner
from .attribute_handler import AttributeHandler
from ..util.dtm_tools_utils import SMOOTH_TOLERANCE, SIMPLIFICATION_METHOD, FIRST_SIMPLIFY_TOLERANCE, \
    SECOND_SIMPLIFY_TOLERANCE, GEOGRAPHIC_CONSTANT, MAX_NODE_ANGLE, COUNTER, get_tolerance_by_interval


class VectorHandler(QObject):
    """
    Docstring
    """

    def __init__(self, iface=None, parent=None):
        super(VectorHandler, self).__init__()
        self.parent = parent
        self.iface = iface
        if iface:
            self.canvas = iface.mapCanvas()
        self.algorithm_runner = AlgorithmRunner(iface)
        self.attribute_handler = AttributeHandler(iface)
        self.smooth_tolerance = SMOOTH_TOLERANCE
        self.first_simplify_tolerance = FIRST_SIMPLIFY_TOLERANCE
        self.second_simplify_tolerance = SECOND_SIMPLIFY_TOLERANCE
        self.geographic_constant = GEOGRAPHIC_CONSTANT
        self.simplification_method = SIMPLIFICATION_METHOD
        self.max_node_angle = MAX_NODE_ANGLE

    def create_feature(self, geometry, attribute_value, error=False):
        # fields_maps = self.attribute_handler.create_fields(True)
        feature = QgsFeature()
        feature.setGeometry(geometry)

        if error:
            feature.setFields(self.attribute_handler.create_fields(None, True))
            feature[0] = attribute_value

        return feature

    def get_outershell_and_holes(self, geom, isMulti):
        outershells, donutholes = [], []
        for part in geom.asGeometryCollection():
            for current, item in enumerate(part.asPolygon()):
                newGeom = QgsGeometry.fromPolygonXY([item])
                if isMulti:
                    newGeom.convertToMultiType()
                if current == 0:
                    outershells.append(newGeom)
                else:
                    donutholes.append(newGeom)
        return outershells, donutholes

    def get_feature_outershell_and_holes(self, feat, isMulti):
        geom = feat.geometry()

        outershells, donutholes = self.get_outershell_and_holes(
            geom, isMulti)
        outershellList = []
        for shell in outershells:
            outerShellFeat = QgsFeature(feat)
            outerShellFeat.setGeometry(shell)
            outershellList.append(outerShellFeat)

        donutHoleList = []
        for hole in donutholes:
            newFeat = QgsFeature(feat)
            newFeat.setGeometry(hole)
            donutHoleList.append(newFeat)
        return outershellList, donutHoleList

    def retrieve_simplified_smoothed_contour(self, contour_lines, input_crs, context=None, feedback=None):

        """
        Retrieve simplified and smoothed contour lines.

        Args:
            contour_lines (QgsVectorLayer): The input vector layer containing contour lines.
            input_crs (QgsCoordinateReferenceSystem): The input CRS (Coordinate Reference System).
            context (QgsProcessingContext): The processing context.
            feedback (QgsProcessingFeedback, optional): Feedback object for processing progress. Default is None.

        Returns:
            QgsVectorLayer: The simplified and smoothed contour lines as a QgsVectorLayer.
        """

        QgsSpatialIndex(contour_lines.getFeatures())

        if input_crs.isGeographic():
            self._adjust_tolerances_for_geographic_crs()

        feedback.pushInfo(self.tr('\nSimplifying and smoothing contours...'))

        smoothed = self.algorithm_runner.run_smooth(
            contour_lines, 2, self.smooth_tolerance, self.max_node_angle)

        first_simplified = self.algorithm_runner.run_simplify(
            smoothed, self.simplification_method, self.first_simplify_tolerance)

        second_smoothed = self.algorithm_runner.run_smooth(
            first_simplified, 3, self.smooth_tolerance, self.max_node_angle)

        last_simplified = self.algorithm_runner.run_simplify(
            second_smoothed, self.simplification_method, self.second_simplify_tolerance)

        if Qgis.QGIS_VERSION_INT >= 32001:
            return self.algorithm_runner.run_delete_field(last_simplified, ['fid'])
        else:
            return self.attribute_handler.delete_fields(last_simplified, ['fid'])

    def _adjust_tolerances_for_geographic_crs(self):
        """
        Adjust the simplification tolerances for geographic CRS.

        The method modifies the following attributes:
            - self.first_simplify_tolerance: The initial tolerance used in the first simplification pass.
            - self.second_simplify_tolerance: The initial tolerance used in the second simplification pass.
        """
        self.first_simplify_tolerance /= self.geographic_constant
        self.second_simplify_tolerance /= self.geographic_constant

    def get_out_of_bounds_angle(self, part, angle, invalid_range=None):
        min_angle, max_angle = 0, 0
        off_bounds_list = list()

        if invalid_range is not None:
            min_angle, max_angle = invalid_range

        line = part.asPolyline()
        number_of_vertex = len(line) - 1

        for i in range(1, number_of_vertex):
            vertex_angle = (line[i].azimuth(line[i - 1]) - line[i].azimuth(line[i + 1]) + 360)
            vertex_angle = math.fmod(vertex_angle, 360)

            if vertex_angle > 180:
                vertex_angle = 360 - vertex_angle

            if invalid_range is not None and (min_angle <= vertex_angle <= max_angle):
                feature = self.create_feature(QgsGeometry.fromPointXY(line[i]), 'out of bounds angle', True)
                off_bounds_list.append(feature)
                continue

            if vertex_angle < angle:
                feature = self.create_feature(QgsGeometry.fromPointXY(line[i]), 'out of bounds angle', True)
                off_bounds_list.append(feature)

        return off_bounds_list

    def numpy_get_out_of_bounds_angle(self, part, angle, invalid_range=None):
        """
        Find vertices in the part with out-of-bounds angles.

        Args:
            part (QgsGeometry): The input part (e.g., a LineString) containing vertices.
            angle (float): The threshold angle, in degrees. Vertices with angles less than this threshold will be considered.
            invalid_range (tuple, optional): A tuple containing the minimum and maximum angles (in degrees) that are considered invalid.
                                             Vertices with angles within this range will be considered out-of-bounds. Default is None.

        Returns:
            list: A list of QgsFeature objects representing vertices with out-of-bounds angles.
        """
        off_bounds_list = list()

        if invalid_range is not None:
            minAngle, maxAngle = invalid_range

        line = part.asPolyline()
        nVertex = len(line)

        if nVertex <= 2:
            # Not enough vertices to calculate angles
            return off_bounds_list

        # Convert the vertices into a NumPy array
        vertices = np.array([[pt.x(), pt.y()] for pt in line])

        # Calculate the angles using NumPy
        angles = np.degrees(np.arctan2(vertices[1:-1, 1] - vertices[:-2, 1], vertices[:-2, 0] - vertices[1:-1, 0]))

        # Adjust angles to be between 0 and 360
        angles = np.mod(angles + 360, 360)

        if invalid_range is not None:
            # Check for angles within the invalid range
            mask_invalid = (angles >= minAngle) & (angles <= maxAngle)
            invalid_indices = np.where(mask_invalid)[0] + 1
            invalid_points = [line[i] for i in invalid_indices]
            off_bounds_list.extend([self.create_feature(QgsGeometry.fromPointXY(pt)) for pt in invalid_points])

        # Check for angles less than the threshold
        mask_out_of_bounds = angles < angle
        out_of_bounds_indices = np.where(mask_out_of_bounds)[0] + 1
        out_of_bounds_points = [line[i] for i in out_of_bounds_indices]
        off_bounds_list.extend([self.create_feature(QgsGeometry.fromPointXY(pt)) for pt in out_of_bounds_points])

        return off_bounds_list

    def filter_self_intersecting_lines(self, contour_lines):
        filtered_features = []
        intersected_features = []

        for feature in contour_lines.getFeatures():
            geometry = feature.geometry()
            if not geometry.intersects(geometry):
                filtered_features.append(feature)
            else:
                intersected_features.append(feature)

        return filtered_features, intersected_features

    def filter_geometry_by_length(self, interval, input_layer, input_crs):
        filter_tolerance = get_tolerance_by_interval(interval, input_crs)

        expression = f'$length < {filter_tolerance}'
        request = QgsFeatureRequest().setFilterExpression(expression)
        to_delete = list()

        for feature in input_layer.getFeatures(request):
            feature.setFields(self.attribute_handler.create_fields(None, True))
            feature[0] = f'contour line with length below tolerance {feature.geometry().length()*self.geographic_constant}'
            to_delete.append(feature)

        # TODO tratar exceção
        self.delete_features(input_layer, to_delete)
        return input_layer, to_delete

    def delete_features(self, input_layer, feature_list):
        to_delete = list()
        for feature in feature_list:
            to_delete.append(feature.id())

        return input_layer.dataProvider().deleteFeatures(to_delete)

    def spatial_index_applier(self, layer):
        index = QgsSpatialIndex()

        for feature in layer.getFeatures():
            index.addFeature(feature)

        return True
