# -*- coding: utf-8 -*-

"""
/***************************************************************************
 AlosContourExtractor
                                 A QGIS plugin
 Creates contour and elevation points from Alos Palsar DEM
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-07-20
        copyright            : (C) 2021 by CamellOnCase
        email                : camelloncase@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Francisco Alves Camello Neto'
__date__ = '2021-07-20'
__copyright__ = '(C) 2021 by CamellOnCase'

import math
import processing
from qgis.analysis import QgsGeometrySnapper, QgsInternalGeometrySnapper
from qgis.core import (edit, Qgis, QgsCoordinateReferenceSystem, QgsCoordinateTransform,
                       QgsExpression, QgsFeature, QgsFeatureRequest, QgsField, QgsGeometry, QgsMessageLog,
                       QgsProcessingContext, QgsProcessingMultiStepFeedback, QgsProcessingUtils, QgsProject,
                       QgsSpatialIndex, QgsVectorDataProvider, QgsVectorLayer, QgsVectorLayerUtils, QgsWkbTypes,
                       QgsProcessingFeatureSourceDefinition, QgsFeatureSink)
from qgis.PyQt.Qt import QObject, QVariant
from ..algorithms.algorithm_runner import AlgorithmRunner
from .attribute_handler import AttributeHandler


class VectorHandler(QObject):
    """
    Docstring
    """

    def __init__(self, iface=None, parent=None):
        super(VectorHandler, self).__init__()
        self.parent = parent
        self.iface = iface
        if iface:
            self.canvas = iface.mapCanvas()
        self.algorithm_runner = AlgorithmRunner(iface)
        self.attribute_handler = AttributeHandler(iface)

    def create_feature(self, geometry, fields=None, set_attributes=False):
        feature = QgsFeature()
        feature.setGeometry(geometry)
        if set_attributes:
            feature.setAttributes(fields)

        return feature

    def get_outershell_and_holes(self, geom, isMulti):
        outershells, donutholes = [], []
        for part in geom.asGeometryCollection():
            for current, item in enumerate(part.asPolygon()):
                newGeom = QgsGeometry.fromPolygonXY([item])
                if isMulti:
                    newGeom.convertToMultiType()
                if current == 0:
                    outershells.append(newGeom)
                else:
                    donutholes.append(newGeom)
        return outershells, donutholes

    def get_feature_outershell_and_holes(self, feat, isMulti):
        geom = feat.geometry()

        outershells, donutholes = self.get_outershell_and_holes(
            geom, isMulti)
        outershellList = []
        for shell in outershells:
            outerShellFeat = QgsFeature(feat)
            outerShellFeat.setGeometry(shell)
            outershellList.append(outerShellFeat)

        donutHoleList = []
        for hole in donutholes:
            newFeat = QgsFeature(feat)
            newFeat.setGeometry(hole)
            donutHoleList.append(newFeat)
        return outershellList, donutHoleList

    def retrieve_simplified_smoothed_contour(self, contour_lines, context, feedback=None):

        smoothed = self.algorithm_runner.run_smooth(
            contour_lines, 2, 0.3, 180, context, feedback=feedback)

        first_simplified = self.algorithm_runner.run_simplify(
            smoothed, 0, 2, context, feedback=feedback)

        second_smoothed = self.algorithm_runner.run_smooth(
            first_simplified, 3, 0.3, 180, context, feedback=feedback)

        last_simplified = self.algorithm_runner.run_simplify(
            second_smoothed, 0, 1, context, feedback=feedback)

        delete_field = self.algorithm_runner.run_delete_field(
            last_simplified, ['fid'], context, feedback=feedback)

        return delete_field

    def get_out_of_bounds_angle(self, part, angle, invalid_range=None):

        off_bounds_list = list()

        if invalid_range is not None:
            minAngle, maxAngle = invalid_range

        line = part.asPolyline()
        nVertex = len(line)-1

        for i in range(1, nVertex):
            vertex_angle = (line[i].azimuth(line[i-1]) -
                            line[i].azimuth(line[i+1]) + 360)
            vertex_angle = math.fmod(vertex_angle, 360)
            if vertex_angle > 180:
                vertex_angle = 360 - vertex_angle
            if invalid_range is not None and (vertex_angle >= minAngle and vertex_angle <= maxAngle):
                feature = self.create_feature(QgsGeometry.fromPointXY(line[i]))
                off_bounds_list.append(feature)
                continue
            if vertex_angle < angle:
                feature = self.create_feature(QgsGeometry.fromPointXY(line[i]))
                self.attribute_handler.set_attribute_value(
                    feature, 'reason', 'spike')
                off_bounds_list.append(feature)

        return off_bounds_list

    def get_contour_intersection(self, contour_lines, context, feedback=None):
        intersection_points = self.algorithm_runner.run_line_intersections(
            contour_lines, context, feedback)
