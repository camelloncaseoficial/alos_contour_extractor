# -*- coding: utf-8 -*-

"""
/***************************************************************************
 AlosContourExtractor
                                 A QGIS plugin
 Creates contour and elevation points from Alos Palsar DEM
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-07-20
        copyright            : (C) 2021 by CamellOnCase
        email                : camelloncase@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Francisco Alves Camello Neto'
__date__ = '2021-07-20'
__copyright__ = '(C) 2021 by CamellOnCase'

import processing
from qgis.analysis import QgsGeometrySnapper, QgsInternalGeometrySnapper
from qgis.core import (edit, Qgis, QgsCoordinateReferenceSystem, QgsCoordinateTransform,
                       QgsExpression, QgsFeature, QgsFeatureRequest, QgsField, QgsGeometry, QgsMessageLog,
                       QgsProcessingContext, QgsProcessingMultiStepFeedback, QgsProcessingUtils, QgsProject,
                       QgsSpatialIndex, QgsVectorDataProvider, QgsVectorLayer, QgsVectorLayerUtils, QgsWkbTypes,
                       QgsProcessingFeatureSourceDefinition, QgsFeatureSink)
from qgis.PyQt.Qt import QObject, QVariant


class AlgorithmRunner():
    """
    Docstring
    """

    def __init__(self, iface=None, parent=None):
        super(AlgorithmRunner, self).__init__()
        self.parent = parent
        self.iface = iface
        if iface:
            self.canvas = iface.mapCanvas()

    def run_buffer(self, inputLayer, distance, context, dissolve=False, endCapStyle=None, joinStyle=None,
                   segments=None, mitterLimit=None, feedback=None, output_layer=None):
        endCapStyle = 0 if endCapStyle is None else endCapStyle
        joinStyle = 0 if joinStyle is None else joinStyle
        segments = 5 if segments is None else segments
        mitterLimit = 2 if mitterLimit is None else mitterLimit
        output_layer = 'memory:' if output_layer is None else output_layer
        parameters = {
            'INPUT': inputLayer,
            'DISTANCE': distance,
            'DISSOLVE': dissolve,
            'END_CAP_STYLE': endCapStyle,
            'JOIN_STYLE': endCapStyle,
            'SEGMENTS': segments,
            'MITER_LIMIT': mitterLimit,
            'OUTPUT': output_layer
        }
        output = processing.run("native:buffer",
                                parameters, context=context, feedback=feedback)
        return output['OUTPUT']

    def run_polygons_to_lines(self, inpuy_layer, context, feedback=None, output_layer=None):
        output_layer = 'memory:' if output_layer is None else output_layer
        parameters = {
            'INPUT': inpuy_layer,
            'OUTPUT': output_layer
        }
        output = processing.run('native:polygonstolines',
                                parameters, context=context, feedback=feedback)
        return output['OUTPUT']

    def run_bounding_box_retrieve(self, inpuy_layer, context, feedback=None, output_layer=None):
        output_layer = 'memory:' if output_layer is None else output_layer
        parameters = {
            'INPUT': inpuy_layer,
            'FIELD': '',
            'TYPE': 1,
            'OUTPUT': output_layer
        }
        output = processing.run("qgis:minimumboundinggeometry",
                                parameters, context=context, feedback=feedback)
        return output['OUTPUT']

    def run_multi_to_single_part(self, inpuy_layer, context, feedback=None, output_layer=None):
        output_layer = 'memory:' if output_layer is None else output_layer
        parameters = {
            'INPUT': inpuy_layer,
            'OUTPUT': output_layer
        }
        output = processing.run('native:multiparttosingleparts',
                                parameters, context=context, feedback=feedback)
        return output['OUTPUT']

    def run_polygonize(self, inpuy_layer, context, keep_fields=True, feedback=None, output_layer=None):
        output_layer = 'memory:' if output_layer is None else output_layer
        parameters = {
            'INPUT': inpuy_layer,
            'KEEP_FIELDS': keep_fields,
            'OUTPUT': output_layer
        }
        output = processing.run('native:polygonize',
                                parameters, context=context, feedback=feedback)
        return output['OUTPUT']
